## 混部和超卖

### 混部

混部，在k8s中，就是一个节点跑多个pod，包括在线和在线，也包括在线和离线。 混部的关键是隔离性。可以说所有使用到的资源，都需要有隔离性，比如cpu，内存，IO，网络，以及更细粒度的打开的文件数，内存带宽。如果某项资源不具备隔离性，实际上都会在混部场景因为资源争抢导致问题。

所以当机器的资源压力比较大的时候，隔离性的问题越需要重点解决，隔离性可以简单理解就是可以为单个pod设置对应资源的最大可使用量（此时应该可以想到limit这个参数）。

默认k8s的隔离性实现方式如下：
- CPU：操作系统的CFS调度， limit生成了cpu.cfs_quota_us参数，cfs_quota_us用来配置当前cgroup在cfs_period_us时间内最多能使用的cpu时间数，单位us。 超过就会被调度器节流。

- 内存：超过会被操作系统OOM。
- 其他：hugepages


除了以上几个资源限制，其实其他资源没有做限制。所以实际上远远不够的。这种情况下，一般场景下，认为cpu 和 memory相对其他资源，更是木桶效应中的短板。


PS：在单纯聊混部的时候，我们假设所有的pod 都不会资源超卖（简单理解就是request等于limit）。

### 超卖

一般来说，由于 1）服务申请的资源偏大，2）在线服务一般来说在时间维度具备潮汐的特性 3）在一台机器上，cpu使用的突刺在同一时刻的概率非常低（参见谷歌对于数据中心研究的论文）

这样的结果就是，一台机器的分配率很高，但是实际使用率却比较低。分配率高，意味着我们很难从调度的手段去做工了。

超卖的意思就是，将这部分闲置的算例抽取出来，2次售卖。

超卖的核心在于各种资源的QoS能力。核心就是在整机资源压力小的时候，一个服务可以使用超过他申请的资源量。这样才能避免浪费。当整机压力比较大的时候，会有优先级控制的能力，优先保障高优先级的服务。

那么在k8s 中，是如何实现的那？

- CPU：request，设置成cpu.shares 值。
- Memory ： request 对应min水线，max水线等于limit * 内存分配限制系数（0.9）.


所以整体上，request 是强保障的资源，超卖的资源是不能强保障的。所以超卖的资源一般都用于支持对资源保障能力要求不高的服务。 这也就是在离线混部。

但是不是说二次售卖的资源，就可以任意的kill 离线服务，实际上要通过一些画像，尽量去保障抽取资源的稳定性。也就是我们常说的驱逐率。

但是超卖不仅仅等于在离线混部，比如云厂商的超卖，超卖给在线服务。 


### 其他保障能力

- 智能绑核



### 干扰监测
隔离性太过于复杂，我们不可能一一都解决。另外就是我们需要保障在线的服务，都需要用干扰监测，监测是不是影响了在线服务。一般来说分为系统侧指标（cpu调度延迟，内存分配延迟， psi），业务侧指标（rt）。



























